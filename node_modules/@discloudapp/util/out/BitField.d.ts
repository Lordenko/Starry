/**
 * @internal
 */
export interface BitFieldConstructor<S extends string, N extends bigint | number> {
    new (...bits: BitFieldResolvable<S, N>[]): BitField<S, N>;
    DefaultBit: N;
    Flags: EnumLike<S, N>;
    resolve(bit: BitFieldResolvable<S, N>): N;
}
export interface BitField<S extends string, N extends bigint | number> {
    constructor: BitFieldConstructor<S, N>;
    /**
     * Bitfield of the packed bits
     */
    bitField: N;
}
/**
 * Data structure that makes it easy to interact with a bitfield.
 */
export declare abstract class BitField<S, N> {
    static DefaultBit: bigint | number;
    /**
     * Numeric bitfield flags.
     * Defined in extension classes
     */
    static Flags: EnumLike<unknown, bigint | number>;
    constructor(...bits: BitFieldResolvable<S, N>[]);
    /**
     * Adds bits to these ones.
     * @param bits - Bits to add
     * @returns These bits or new BitField if the instance is frozen.
     */
    add(...bits: BitFieldResolvable<S, N>[]): this;
    /**
     * Checks whether the bitfield has a bit, or any of multiple bits.
     * @param bits - Bit(s) to check for
     */
    any(...bits: BitFieldResolvable<S, N>[]): boolean;
    /**
     * Checks if this bitfield equals another
     * @param bits - Bit(s) to check for
     */
    equals(...bits: BitFieldResolvable<S, N>[]): boolean;
    /**
     * Freezes these bits, making them immutable.
     */
    freeze(): Readonly<this>;
    /**
     * Checks whether the bitfield has a bit, or multiple bits.
     * @param bits - Bit(s) to check for
     */
    has(...bits: BitFieldResolvable<S, N>[]): boolean;
    /**
     * Gets all given bits that are missing from the bitfield.
     * @param bits - Bit(s) to check for
     */
    missing(...bits: BitFieldResolvable<S, N>[]): S[];
    /**
     * Removes bits from these.
     * @param bits - Bits to remove
     * @returns These bits or new BitField if the instance is frozen.
     */
    remove(...bits: BitFieldResolvable<S, N>[]): this;
    /**
     * Gets an object mapping field names to a {@link boolean} indicating whether the
     * bit is available.
     */
    serialize(): Record<S, boolean>;
    /**
     * Replace the bits with these.
     * @param bits - bits to set
     * @returns These bits or new BitField if the instance is frozen.
     */
    set(...bits: BitFieldResolvable<S, N>[]): this;
    /**
     * Gets an {@link Array} of bitfield names based on the bits available.
     */
    toArray(): S[];
    toJSON(): string | (N & number);
    valueOf(): N;
    [Symbol.iterator](): Generator<S, void, unknown>;
    /**
     * Resolves bitfields to their numeric form.
     * @param bit - bit(s) to resolve
     */
    static resolve<S extends string, N extends bigint | number>(bit: BitFieldResolvable<S, N>): N;
}
/**
 * Data that can be resolved to give a bitfield. This can be:
 * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})
 * * A string bit number
 * * An instance of BitField
 * * An Array of BitFieldResolvable
 */
export type BitFieldResolvable<S extends string, N extends bigint | number> = `${bigint}` | number | N | S | BitField<S, N> | BitFieldResolvable<S, N>[];
type EnumLike<E, V> = Record<keyof E, V>;
export default BitField;
//# sourceMappingURL=BitField.d.ts.map