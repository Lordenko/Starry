"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreFiles = exports.allBlockedFilesRegex = exports.allBlockedFiles = exports.blockedFiles = void 0;
const fs_1 = require("fs");
const glob_1 = require("glob");
const os_1 = require("os");
const path_1 = require("path");
exports.blockedFiles = {
    common: [".git", ".vscode", ".cache"],
    go: [],
    js: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
    py: ["venv"],
    rb: ["Gemfile.lock"],
    rs: ["Cargo.lock", "target"],
    ts: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
};
exports.allBlockedFiles = Array.from(new Set(Object.values(exports.blockedFiles).flat()));
exports.allBlockedFilesRegex = RegExp(`(${exports.allBlockedFiles.join("|")})$`.replace(/\./g, "\\."), "i");
class IgnoreFiles {
    fileName;
    filesIgnore = new Set();
    list = exports.allBlockedFiles;
    paths = new Set();
    constructor(options) {
        this.fileName = options.fileName;
        if (options.optionalIgnoreList?.length) {
            this.list = Array.from(new Set(this.list.concat(IgnoreFiles.normalizePaths(options.optionalIgnoreList))));
        }
        for (let i = 0; i < this.list.length; i++) {
            this.list[i] = IgnoreFiles.normalizeIgnore(this.list[i]);
        }
        if (Array.isArray(options.path)) {
            this.paths = new Set(IgnoreFiles.normalizePaths(options.path));
        }
        else if (options.path) {
            this.paths.add(IgnoreFiles.normalizePath(options.path));
        }
        if (this.fileName)
            this.filesIgnore = IgnoreFiles.findIgnoreFiles(this.fileName, this.paths, this.list);
        if (this.filesIgnore.size)
            this.list = Array.from(new Set(this.list.concat(this.processIgnoreFiles(this.filesIgnore))));
    }
    static findIgnoreFiles(fileName, paths, ignore) {
        const files = [];
        for (const path of paths) {
            files.push((0, glob_1.globSync)((0, path_1.join)(path, "**", fileName), {
                dot: true,
                ignore,
                windowsPathsNoEscape: (0, os_1.type)() === "Windows_NT",
            }));
        }
        return new Set(files.flat());
    }
    static normalizeIgnore(ignore, path = "**") {
        return (0, path_1.join)(path, ignore, "**").replace(/\\/g, "/");
    }
    static normalizePath(path) {
        return (0, path_1.join)(...path.split(/[\\/]/));
    }
    static normalizePaths(paths) {
        for (let i = 0; i < paths.length; i++) {
            paths[i] = this.normalizePath(paths[i]);
        }
        return paths;
    }
    static processIgnoreFile(file) {
        const dir = (0, path_1.dirname)(file).replace(/^[.]$/, "") || "**";
        const list = (0, fs_1.readFileSync)(file, "utf8")
            .replace(/\s*#.*/g, "")
            .split(/[\r\n]+/)
            .filter(Boolean);
        const ignore = [];
        for (const iterator of list) {
            ignore.push(this.normalizeIgnore(iterator, dir));
        }
        return ignore;
    }
    processIgnoreFiles(files = this.filesIgnore) {
        const ignore = [];
        for (const file of files) {
            ignore.push(IgnoreFiles.processIgnoreFile(file));
        }
        return ignore.flat();
    }
}
exports.IgnoreFiles = IgnoreFiles;
