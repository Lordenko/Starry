"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitField = void 0;
/**
 * Data structure that makes it easy to interact with a bitfield.
 */
class BitField {
    static DefaultBit = 0;
    /**
     * Numeric bitfield flags.
     * Defined in extension classes
     */
    static Flags = {};
    constructor(...bits) {
        this.bitField = this.constructor.resolve(bits ?? this.constructor.DefaultBit);
    }
    /**
     * Adds bits to these ones.
     * @param bits - Bits to add
     * @returns These bits or new BitField if the instance is frozen.
     */
    add(...bits) {
        // @ts-expect-error ts(2362)
        const total = bits.reduce((p, b) => p | this.constructor.resolve(b), this.constructor.DefaultBit);
        // @ts-expect-error ts(2322)
        if (Object.isFrozen(this))
            return new this.constructor(this.bitField | total);
        // @ts-expect-error ts(2363)
        this.bitField |= total;
        return this;
    }
    /**
     * Checks whether the bitfield has a bit, or any of multiple bits.
     * @param bits - Bit(s) to check for
     */
    any(...bits) {
        return (this.bitField & this.constructor.resolve(bits)) !== this.constructor.DefaultBit;
    }
    /**
     * Checks if this bitfield equals another
     * @param bits - Bit(s) to check for
     */
    equals(...bits) {
        return this.bitField === this.constructor.resolve(bits);
    }
    /**
     * Freezes these bits, making them immutable.
     */
    freeze() {
        return Object.freeze(this);
    }
    /**
     * Checks whether the bitfield has a bit, or multiple bits.
     * @param bits - Bit(s) to check for
     */
    has(...bits) {
        const bit = this.constructor.resolve(bits);
        return (this.bitField & bit) === bit;
    }
    /**
     * Gets all given bits that are missing from the bitfield.
     * @param bits - Bit(s) to check for
     */
    missing(...bits) {
        return new this.constructor(bits).remove(this).toArray();
    }
    /**
     * Removes bits from these.
     * @param bits - Bits to remove
     * @returns These bits or new BitField if the instance is frozen.
     */
    remove(...bits) {
        // @ts-expect-error ts(2362)
        const total = bits.reduce((p, b) => p | this.constructor.resolve(b), this.constructor.DefaultBit);
        // @ts-expect-error ts(2322)
        if (Object.isFrozen(this))
            return new this.constructor(this.bitField & ~total);
        // @ts-expect-error ts(2322)
        this.bitField &= ~total;
        return this;
    }
    /**
     * Gets an object mapping field names to a {@link boolean} indicating whether the
     * bit is available.
     */
    serialize() {
        return Object.entries(this.constructor.Flags)
            .reduce((acc, [flag, bit]) => Object.assign(acc, { [flag]: this.has(bit) }), {});
    }
    /**
     * Replace the bits with these.
     * @param bits - bits to set
     * @returns These bits or new BitField if the instance is frozen.
     */
    set(...bits) {
        // @ts-expect-error ts(2322)
        if (Object.isFrozen(this))
            return new this.constructor(bits);
        this.bitField = this.constructor.resolve(bits);
        return this;
    }
    /**
     * Gets an {@link Array} of bitfield names based on the bits available.
     */
    toArray() {
        // @ts-expect-error ts(2345)
        return Object.keys(this.constructor.Flags).filter(bit => this.has(bit));
    }
    toJSON() {
        return typeof this.bitField === "number" ? this.bitField : this.bitField.toString();
    }
    valueOf() {
        return this.bitField;
    }
    *[Symbol.iterator]() {
        for (const flag of this.toArray()) {
            yield flag;
        }
    }
    /**
     * Resolves bitfields to their numeric form.
     * @param bit - bit(s) to resolve
     */
    static resolve(bit) {
        if (bit instanceof BitField)
            return bit.bitField;
        const DefaultBit = this.DefaultBit;
        // @ts-expect-error ts(2322)
        if (Array.isArray(bit))
            return bit.reduce((p, b) => p | this.resolve(b), DefaultBit);
        // @ts-expect-error ts(2322) ts(2365)
        if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
            return bit;
        if (typeof bit === "string") {
            // @ts-expect-error ts(7053)
            if (this.Flags[bit] !== undefined)
                return this.Flags[bit];
            // @ts-expect-error ts(2322)
            if (!isNaN(Number(bit)))
                return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        }
        throw new RangeError(`Invalid BitField: ${bit}`);
    }
}
exports.BitField = BitField;
exports.default = BitField;
