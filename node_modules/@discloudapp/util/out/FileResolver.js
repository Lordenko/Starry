"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamToBlob = exports.streamToFile = exports.resolveFileSync = exports.resolveFile = exports.fileNamePattern = void 0;
const fs_1 = require("fs");
const stream_1 = require("stream");
exports.fileNamePattern = /.*\/+([^?#]+)(?:[?#].*)?/;
/**
 * A function that converts {@link FileResolvable} to {@link File}
 *
 * @param file - The file as {@link FileResolvable} to resolve
 * @param fileName - The name of the file to upload
 */
async function resolveFile(file, fileName) {
    if (file instanceof File)
        return file;
    if (file instanceof URL || typeof file === "string") {
        file = file.toString();
        fileName ??= file.match(exports.fileNamePattern)?.pop();
        if (/^(?:s?ftp|https?):\/\//.test(file)) {
            const response = await fetch(file);
            if (response.status > 399)
                throw response;
            return response.blob()
                .then(blob => new File([blob], fileName ?? `file.${resolveBlobFileType(blob)}`, { type: blob.type }));
        }
        if ((0, fs_1.existsSync)(file))
            return streamToFile((0, fs_1.createReadStream)(file), fileName ?? "file.zip");
        return new File([file], fileName ?? "file.zip");
    }
    if (file instanceof Blob)
        return new File([file], fileName ?? `file.${resolveBlobFileType(file)}`, { type: file.type });
    fileName ??= "file.zip";
    if (Buffer.isBuffer(file))
        return new File([file], fileName);
    if ("data" in file) {
        if (file.data instanceof File)
            return file.data;
        return new File([file.data], file.name, { type: file.contentType });
    }
    if (!stream_1.Stream.isErrored(file))
        return streamToFile(file, fileName);
    throw new TypeError("Invalid file type was provided.");
}
exports.resolveFile = resolveFile;
function resolveFileSync(file, fileName) {
    if (file instanceof File)
        return file;
    fileName ??= "file.zip";
    if (typeof file === "string") {
        return new File([file], fileName);
    }
    if (file instanceof Blob)
        return new File([file], fileName);
    if (Buffer.isBuffer(file))
        return new File([file], fileName);
    if ("data" in file) {
        if (file.data instanceof File)
            return file.data;
        return new File([file.data], file.name);
    }
    throw new TypeError("Invalid file type was provided.");
}
exports.resolveFileSync = resolveFileSync;
/**
 * A function that converts a like {@link Stream} parameter to {@link File}
 *
 * @param stream - A parameter like {@link Readable} or {@link Writable}
 * @param fileName - A file name, if you wish
 * @param mimeType - A mimeType parameter
 */
function streamToFile(stream, fileName, mimeType) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", chunk => chunks.push(chunk))
            .once("end", () => resolve(new File(chunks, fileName ?? "file.zip", { type: mimeType })))
            .once("error", reject);
    });
}
exports.streamToFile = streamToFile;
/**
 * A function that converts a like {@link Stream} parameter to {@link Blob}
 *
 * @param stream - A parameter like {@link Readable} or {@link Writable}
 * @param mimeType - A mimeType parameter
 */
function streamToBlob(stream, mimeType) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", chunk => chunks.push(chunk))
            .once("end", () => resolve(new Blob(chunks, { type: mimeType })))
            .once("error", reject);
    });
}
exports.streamToBlob = streamToBlob;
exports.default = resolveFile;
function resolveBlobFileType(b) {
    if (typeof b === "string")
        return b.split("/")[1].split(/\W/)[0];
    return resolveBlobFileType(b.type);
}
