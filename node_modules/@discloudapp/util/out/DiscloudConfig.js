"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscloudConfig = void 0;
const tslib_1 = require("tslib");
const v2_1 = require("@discloudapp/api-types/v2");
const events_1 = tslib_1.__importDefault(require("events"));
const fs_1 = require("fs");
const path_1 = require("path");
class DiscloudConfig extends events_1.default {
    path;
    static fileName = "discloud.config";
    #watcher;
    #data = {};
    #comments = [];
    constructor(path) {
        super({ captureRejections: true });
        this.path = path;
        try {
            this.path = (0, path_1.join)(...path.split(/[\\/]/g));
            while (!this.exists)
                this.path = (0, path_1.dirname)(this.path);
            if (this.exists && this.isFile && (0, path_1.basename)(this.path) !== DiscloudConfig.fileName) {
                this.path = (0, path_1.dirname)(this.path);
            }
            this.path = (0, path_1.join)(this.path, DiscloudConfig.fileName);
            if (this.isFile) {
                this.#watch();
                this.#onChange();
            }
        }
        catch { }
    }
    dispose() {
        this.emit("disposed", this.#data);
        this.removeAllListeners();
        this.#watcher?.removeAllListeners().close();
    }
    #watch() {
        try {
            this.#watcher = (0, fs_1.watch)(this.path).on("change", this.#onChange).once("close", () => this.dispose());
        }
        catch (_) { }
    }
    #onChange() {
        try {
            const content = (0, fs_1.readFileSync)(this.path, "utf8");
            this.#data = this.#configToObj(content);
            this.#comments = content.split(/\r?\n/).filter(a => /^\s*#/.test(a));
            this.emit("change", this.#data);
        }
        catch {
            this.emit("missing", this.#data);
            this.#data = {};
            this.#comments = [];
        }
    }
    get comments() {
        return this.#comments;
    }
    get data() {
        return this.#data;
    }
    get exists() {
        return (0, fs_1.existsSync)(this.path);
    }
    get isFile() {
        try {
            return (0, fs_1.statSync)(this.path).isFile();
        }
        catch (_) {
            return false;
        }
    }
    get existsMain() {
        const mainPath = (0, path_1.join)((0, path_1.dirname)(this.path), this.data.MAIN);
        if ((0, fs_1.existsSync)(mainPath)) {
            const stats = (0, fs_1.statSync)(mainPath);
            if (stats.isFile())
                return "file";
            if (stats.isDirectory())
                return "dir";
        }
        return false;
    }
    get mainFileExt() {
        return this.data.MAIN?.split(".").pop();
    }
    get missingProps() {
        return this.#requiredProps
            .filter(key => !this.data[key]);
    }
    get #requiredProps() {
        return v2_1.discloudConfigRequiredScopes[this.data.TYPE] ??
            v2_1.discloudConfigRequiredScopes.common;
    }
    #objToString(obj) {
        if (obj === null || obj === undefined)
            return "";
        if (typeof obj === "function")
            return this.#configToObj(obj());
        if (!obj)
            return `${obj}`;
        const result = [];
        if (typeof obj === "object") {
            if (Array.isArray(obj)) {
                for (const value of obj)
                    result.push(this.#objToString(value));
            }
            else {
                const keys = Object.keys(obj);
                for (const key of keys)
                    result.push(`${key}=${this.#objToString(obj[key])}`);
            }
        }
        else {
            result.push(obj);
        }
        return result.filter(Boolean).join("\n");
    }
    #configToObj(s) {
        if (typeof s !== "string")
            return {};
        return this.#processValues(Object.fromEntries(s
            .replace(/\s*#.*/g, "")
            .split(/[\r\n]/)
            .filter(Boolean)
            .map(line => line.split("="))));
    }
    #nonProcessScopes = [
        v2_1.DiscloudConfigScopes.APT,
        v2_1.DiscloudConfigScopes.AVATAR,
        v2_1.DiscloudConfigScopes.BUILD,
        v2_1.DiscloudConfigScopes.ID,
        v2_1.DiscloudConfigScopes.MAIN,
        v2_1.DiscloudConfigScopes.NAME,
        v2_1.DiscloudConfigScopes.START,
        v2_1.DiscloudConfigScopes.TYPE,
        v2_1.DiscloudConfigScopes.VERSION,
    ];
    #processValues(obj) {
        if (!obj)
            return obj;
        const keys = Object.keys(obj);
        for (const key of keys) {
            if (this.#nonProcessScopes.includes(key))
                continue;
            const value = obj[key];
            if (!isNaN(Number(value))) {
                obj[key] = Number(value);
                continue;
            }
            if (["true", "false"].includes(obj[key])) {
                obj[key] = value == "true";
                continue;
            }
        }
        return obj;
    }
    get(key) {
        return this.data[key];
    }
    set(key, value) {
        this.update({ [key]: value });
    }
    update(save, comments = this.comments) {
        try {
            save = Object.assign(this.data, save);
            (0, fs_1.writeFileSync)(this.path, this.#objToString(comments?.length ?
                [comments, save] :
                save), "utf8");
        }
        catch (error) {
            return error;
        }
    }
}
exports.DiscloudConfig = DiscloudConfig;
