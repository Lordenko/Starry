"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const v2_1 = require("@discloudapp/api-types/v2");
const rest_1 = require("@discloudapp/rest");
const util_1 = require("@discloudapp/util");
const http2_1 = require("http2");
const zod_1 = tslib_1.__importDefault(require("zod"));
const AppBackup_1 = tslib_1.__importDefault(require("../structures/AppBackup"));
const TeamApp_1 = tslib_1.__importDefault(require("../structures/TeamApp"));
const CachedManager_1 = tslib_1.__importDefault(require("./CachedManager"));
/**
 * Manager for your team on Discloud
 */
class TeamAppManager extends CachedManager_1.default {
    constructor(discloudApp) {
        super(discloudApp, TeamApp_1.default);
    }
    async status(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.teamStatus(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of this._addMany(data.apps).values()) {
                cache.set(app.id, app.status);
            }
            return cache;
        }
        return this._add(data.apps).status;
    }
    async terminal(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.teamLogs(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of data.apps) {
                cache.set(app.id, app.terminal);
            }
            return cache;
        }
        else {
            return data.apps.terminal;
        }
    }
    async backup(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.teamBackup(appID));
        if (Array.isArray(data.backups)) {
            const cache = new Map();
            for (const backup of data.backups) {
                cache.set(backup.id, new AppBackup_1.default(this.discloudApp, backup));
            }
            return cache;
        }
        return new AppBackup_1.default(this.discloudApp, data.backups);
    }
    /**
     * Set the quantity of ram to application of your team
     *
     * @param appID - Your team app id
     * @param quantity - Minimum values is `100` to `bot` or `512` for `site`
     */
    async ram(appID, quantity) {
        zod_1.default.string().parse(appID);
        zod_1.default.number().parse(quantity);
        const data = await this.discloudApp.rest.put(v2_1.Routes.teamRam(appID), {
            body: {
                ramMB: quantity,
            },
        });
        if (data.statusCode === 200)
            this._add({
                id: appID,
                ram: quantity,
            });
        return data;
    }
    /**
     * Update an of your team apps on Discloud
     *
     * @param appID - Your team app id
     * @param options - Options to update your app.
     */
    async update(appID, options) {
        zod_1.default.string().parse(appID);
        options.file = await (0, util_1.resolveFile)(options.file);
        const data = await this.discloudApp.rest.put(v2_1.Routes.teamCommit(appID), {
            file: options.file,
        });
        return data;
    }
    async restart(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.teamRestart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.restarted.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async start(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.teamStart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.started.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async stop(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.teamStop(appID));
        if ("apps" in data) {
            this._addMany(data.apps.stoped.map(app => ({
                id: app,
                online: false,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: !(data.status === "ok"),
        });
        return data;
    }
    /**
     * Get information of your team application on Discloud.
     */
    async fetch() {
        try {
            const data = await this.discloudApp.rest.get(v2_1.Routes.team());
            this._clear(data.apps);
            return this._addMany(data.apps);
        }
        catch (error) {
            if (error instanceof rest_1.DiscloudAPIError) {
                switch (error.code) {
                    case http2_1.constants.HTTP_STATUS_NOT_FOUND:
                        this._clear();
                        break;
                    default: throw error;
                }
            }
            throw error;
        }
    }
}
exports.default = TeamAppManager;
