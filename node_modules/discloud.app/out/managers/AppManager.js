"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const v2_1 = require("@discloudapp/api-types/v2");
const rest_1 = require("@discloudapp/rest");
const util_1 = require("@discloudapp/util");
const http2_1 = require("http2");
const zod_1 = tslib_1.__importDefault(require("zod"));
const _types_1 = require("../@types");
const App_1 = tslib_1.__importDefault(require("../structures/App"));
const AppBackup_1 = tslib_1.__importDefault(require("../structures/AppBackup"));
const AppUploaded_1 = tslib_1.__importDefault(require("../structures/AppUploaded"));
const CachedManager_1 = tslib_1.__importDefault(require("./CachedManager"));
/**
 * Manager for apps on Discloud
 */
class AppManager extends CachedManager_1.default {
    constructor(discloudApp) {
        super(discloudApp, App_1.default);
    }
    async status(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appStatus(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of this._addMany(data.apps).values()) {
                cache.set(app.id, app.status);
            }
            return cache;
        }
        return this._add(data.apps).status;
    }
    /**
     * Send a command to your app's terminal
     *
     * @param appID - Your app id
     * @param command - The command
     */
    async console(appID, command) {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appConsole(appID), {
            body: {
                command,
            },
        });
        return data.apps.shell.cmd;
    }
    async terminal(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appLogs(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of data.apps) {
                cache.set(app.id, app.terminal);
            }
            return cache;
        }
        return data.apps.terminal;
    }
    async backup(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appBackup(appID));
        if (Array.isArray(data.backups)) {
            const cache = new Map();
            for (const backup of data.backups) {
                cache.set(backup.id, new AppBackup_1.default(this.discloudApp, backup));
            }
            return cache;
        }
        return new AppBackup_1.default(this.discloudApp, data.backups);
    }
    /**
     * Set the quantity of ram to your application
     *
     * @param appID - Your app id
     * @param quantity - Minimum values is `100` to `bot` or `512` for `site`
     */
    async ram(appID, quantity) {
        zod_1.default.string().parse(appID);
        zod_1.default.number().min(100).parse(quantity);
        const data = await this.discloudApp.rest.put(v2_1.Routes.appRam(appID), {
            body: {
                ramMB: quantity,
            },
        });
        if (data.status === "ok")
            this._add({
                id: appID,
                ram: quantity,
            });
        return data;
    }
    /**
     * Upload a new app or site to Discloud
     *
     * @param options - Options for create a new app. A {@link FileResolvable} is required.
     */
    async create(options) {
        options.file = await (0, util_1.resolveFile)(options.file);
        const data = await this.discloudApp.rest.post(v2_1.Routes.upload(), {
            file: options.file,
        });
        if ("app" in data) {
            this._add(data.app);
            return Object.assign({}, data, { app: new AppUploaded_1.default(this.discloudApp, data.app) });
        }
        return data;
    }
    /**
     * Update an of your apps on Discloud.
     *
     * @param appID - Your app id
     * @param options - Options to update your app.
     */
    async update(appID, options) {
        zod_1.default.string().parse(appID);
        options.file = await (0, util_1.resolveFile)(options.file);
        const data = await this.discloudApp.rest.put(v2_1.Routes.appCommit(appID), {
            file: options.file,
        });
        return data;
    }
    async delete(appID = "all") {
        const data = await this.discloudApp.rest.delete(v2_1.Routes.appDelete(appID));
        if ("apps" in data) {
            this._deleteMany(data.apps.removealled);
            return data.apps;
        }
        if (data.status === "ok")
            this._delete(appID);
        return data;
    }
    /**
     * Update the profile of your apps on Discloud.
     *
     * @param appID - Your app id
     * @param options - Options to update your app.
     */
    async profile(appID, options) {
        _types_1.ProfileOptions.parse(options);
        const data = await this.discloudApp.rest.put(v2_1.Routes.appProfile(appID), {
            body: options,
        });
        if (data.status === "ok")
            this._add(options);
        return data;
    }
    async restart(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appRestart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.restarted.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async start(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appStart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.started.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async stop(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appStop(appID));
        if ("apps" in data) {
            this._addMany(data.apps.stoped.map(app => ({
                id: app,
                online: false,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: !(data.status === "ok"),
        });
        return data;
    }
    async fetch(appID = "all") {
        if (appID === "all")
            return this.#fetchMany();
        try {
            const data = await this.discloudApp.rest.get(v2_1.Routes.app(appID));
            return this._add(data.apps);
        }
        catch (error) {
            if (error instanceof rest_1.DiscloudAPIError) {
                switch (error.code) {
                    case http2_1.constants.HTTP_STATUS_NOT_FOUND:
                        this._delete(appID);
                        break;
                    default: throw error;
                }
            }
            throw error;
        }
    }
    async #fetchMany() {
        try {
            const data = await this.discloudApp.rest.get(v2_1.Routes.app("all"));
            this._clear(data.apps);
            return this._addMany(data.apps);
        }
        catch (error) {
            if (error instanceof rest_1.DiscloudAPIError) {
                switch (error.code) {
                    case http2_1.constants.HTTP_STATUS_NOT_FOUND:
                        this._clear();
                        break;
                    default: throw error;
                }
            }
            throw error;
        }
    }
}
exports.default = AppManager;
